# CSES swap game

## 題意

- 給你一個 $3 \times 3 \texttt{ grid}$ 如下

```
1 2 3
4 5 6
7 8 9
```

- 問你給你另一個也是由 $1\sim 9$ 組成的 $\texttt{grid}$ 從原來的變成現在的要最少多少操作
- 每次操作可以 $\texttt{swap}$ 相鄰兩個數

## 想法
$$\left( \sum_{k=1}^n a_k b_k \right)^2 \leq \left( \sum_{k=1}^n a_k^2 \right) \left( \sum_{k=1}^n b_k^2 \right)$$

- $3 \times 3 \Rightarrow$ 最多也才 $9$ 皆乘種狀態
  - 暴力 $\texttt{BFS}$
- 需 $\texttt{grid}$ 壓成一個數字
  - $\texttt{hash}$
  - $\sum_{k=1}^n$
  - $G=\sum^{8}_{i=0} a_i\times 9^{i}$
  - 其中 $a_i$ 為把位置在 $(r,c)=(\frac{i}{3},i \% 3)$ ( 其中 $i$ 跟 $r,c$ 都是 $\texttt{zero-base}$ )  的數字
    - 注意 $a_i$ 我會把他轉乘範圍是 $0\sim 8$ 把數字壓小一點
  - 查詢的部分直接 $a_i=(G/9^i) \% 9$
  - 因為若 $9^j \lt 9^i$ 那他就會直接被除掉，那 $9^i<9^j$ 就會被 $\% 9$ 給 $\texttt{mod}$ 掉
  - 下面就來證明一個比較誇張的例子來證明為什麼會被除掉

> $\texttt{proof: } \sum_{i=0}^k 8\times 9^i\lt 1 \times 9^{k+1}$
>
> $\sum_{i=0}^k 8\times 9^i$
>
> $=8\times \frac{9^0\times (9^{k+1}-1)}{9-1}$
>
> $=8\times \frac{1\times (9^{k+1}-1)}{8}$
>
> $=9^{k+1}-1$
>
> $9^{k+1}-1 \lt 9^{k+1}$ 故得證

## CODE

```cpp
#include <bits/stdc++.h>
#define int long long
#define pii pair<int, int>
#define pb push_back
#define mk make_pair
#define F first
#define S second
#define ALL(x) x.begin(), x.end()
 
using namespace std;
using PQ = priority_queue<int, vector<int>, greater<int>>;
 
const int INF = 2e18;
const int maxn = 3e5 + 5;
const int M = 1e9 + 7;
const int X = 9;
 
int H[11];
int n = 3;
int G, T;
bitset<387420489> dis;
 
int swap (int i, int j, int U) {
    int a = (U / H[i]) % X;
    int b = (U / H[j]) % X;
    U += (b - a) * H[i];
    U += (a - b) * H[j];
 
    return U;
}
 
int BFS (int G) {
    queue<pii> q;
    q.push ({G, 0}); // 若直接將 G 塞入 map 存 distance 會爆
    dis[G] = 1;
 
    while (q.size()) {
        auto [U, s] = q.front ();
        q.pop ();
        if (U == T) return s;
 
        for (int i = 0; i < 9; i++) {
            if (i % 3 != 2) {
                int C = swap (i, i + 1, U);
                if (!dis[C]) {
                    q.push ({C, s + 1});
                    dis[C] = 1;
                }
            }
            if (i < 6) {
                int C = swap (i, i + 3, U);
                if (!dis[C]) {
                    q.push ({C, s + 1});
                    dis[C] = 1;
                }
            }
        }
    }
}
 
void init () {
    H[0] = 1;
    for (int i = 1; i <= 9; i++) {
        H[i] = H[i - 1] * X;
    }
    for (int i = 0; i < 9; i++) {
        T += i * H[i];
    }
    int x;
    for (int i = 0; i < 9; i++) {
        cin >> x;
        x--;
        G += x * H[i];
    }
}
 
void solve () {
    cout << BFS(G) << "\n";
} 
 
signed main() {
    // ios::sync_with_stdio(0);
    // cin.tie(0);
    int t = 1;
    //cin >> t;
    while (t--) {
        init();
        solve();
    }
} 
```
